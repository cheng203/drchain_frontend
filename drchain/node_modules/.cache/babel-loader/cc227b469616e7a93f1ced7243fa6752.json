{"ast":null,"code":"/* eslint no-loop-func: 0*/\nimport { Children } from 'react';\nimport warning from 'warning';\nvar DRAG_SIDE_RANGE = 0.25;\nvar DRAG_MIN_GAP = 2;\nexport function arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n\n  return clone;\n}\nexport function arrAdd(list, value) {\n  var clone = list.slice();\n\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getPosition(level, index) {\n  return level + '-' + index;\n}\nexport function getNodeChildren(children) {\n  var childList = Array.isArray(children) ? children : [children];\n  return childList.filter(function (child) {\n    return child && child.type && child.type.isTreeNode;\n  });\n}\nexport function isCheckDisabled(node) {\n  var _ref = node.props || {},\n      disabled = _ref.disabled,\n      disableCheckbox = _ref.disableCheckbox;\n\n  return !!(disabled || disableCheckbox);\n}\nexport function traverseTreeNodes(treeNodes, subTreeData, callback) {\n  if (typeof subTreeData === 'function') {\n    callback = subTreeData;\n    subTreeData = false;\n  }\n\n  function processNode(node, index, parent) {\n    var children = node ? node.props.children : treeNodes;\n    var pos = node ? getPosition(parent.pos, index) : 0; // Filter children\n\n    var childList = getNodeChildren(children); // Process node if is not root\n\n    if (node) {\n      var data = {\n        node: node,\n        index: index,\n        pos: pos,\n        key: node.key || pos,\n        parentPos: parent.node ? parent.pos : null\n      }; // Children data is not must have\n\n      if (subTreeData) {\n        // Statistic children\n        var subNodes = [];\n        Children.forEach(childList, function (subNode, subIndex) {\n          // Provide limit snapshot\n          var subPos = getPosition(pos, index);\n          subNodes.push({\n            node: subNode,\n            key: subNode.key || subPos,\n            pos: subPos,\n            index: subIndex\n          });\n        });\n        data.subNodes = subNodes;\n      } // Can break traverse by return false\n\n\n      if (callback(data) === false) {\n        return;\n      }\n    } // Process children node\n\n\n    Children.forEach(childList, function (subNode, subIndex) {\n      processNode(subNode, subIndex, {\n        node: node,\n        pos: pos\n      });\n    });\n  }\n\n  processNode(null);\n}\n/**\n * [Legacy] Return halfChecked when it has value.\n * @param checkedKeys\n * @param halfChecked\n * @returns {*}\n */\n\nexport function getStrictlyValue(checkedKeys, halfChecked) {\n  if (halfChecked) {\n    return {\n      checked: checkedKeys,\n      halfChecked: halfChecked\n    };\n  }\n\n  return checkedKeys;\n}\nexport function getFullKeyList(treeNodes) {\n  var keyList = [];\n  traverseTreeNodes(treeNodes, function (_ref2) {\n    var key = _ref2.key;\n    keyList.push(key);\n  });\n  return keyList;\n}\n/**\n * Check position relation.\n * @param parentPos\n * @param childPos\n * @param directly only directly parent can be true\n * @returns {boolean}\n */\n\nexport function isParent(parentPos, childPos) {\n  var directly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!parentPos || !childPos || parentPos.length > childPos.length) return false;\n  var parentPath = posToArr(parentPos);\n  var childPath = posToArr(childPos); // Directly check\n\n  if (directly && parentPath.length !== childPath.length - 1) return false;\n  var len = parentPath.length;\n\n  for (var i = 0; i < len; i += 1) {\n    if (parentPath[i] !== childPath[i]) return false;\n  }\n\n  return true;\n}\n/**\n * Statistic TreeNodes info\n * @param treeNodes\n * @returns {{}}\n */\n\nexport function getNodesStatistic(treeNodes) {\n  var statistic = {\n    keyNodes: {},\n    posNodes: {},\n    nodeList: []\n  };\n  traverseTreeNodes(treeNodes, true, function (_ref3) {\n    var node = _ref3.node,\n        index = _ref3.index,\n        pos = _ref3.pos,\n        key = _ref3.key,\n        subNodes = _ref3.subNodes,\n        parentPos = _ref3.parentPos;\n    var data = {\n      node: node,\n      index: index,\n      pos: pos,\n      key: key,\n      subNodes: subNodes,\n      parentPos: parentPos\n    };\n    statistic.keyNodes[key] = data;\n    statistic.posNodes[pos] = data;\n    statistic.nodeList.push(data);\n  });\n  return statistic;\n}\nexport function getDragNodesKeys(treeNodes, node) {\n  var _node$props = node.props,\n      eventKey = _node$props.eventKey,\n      pos = _node$props.pos;\n  var dragNodesKeys = [];\n  traverseTreeNodes(treeNodes, function (_ref4) {\n    var nodePos = _ref4.pos,\n        key = _ref4.key;\n\n    if (isParent(pos, nodePos)) {\n      dragNodesKeys.push(key);\n    }\n  });\n  dragNodesKeys.push(eventKey || pos);\n  return dragNodesKeys;\n} // Only used when drag, not affect SSR.\n\nexport function calcDropPosition(event, treeNode) {\n  var clientY = event.clientY;\n\n  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),\n      top = _treeNode$selectHandl.top,\n      bottom = _treeNode$selectHandl.bottom,\n      height = _treeNode$selectHandl.height;\n\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\n\n  if (clientY <= top + des) {\n    return -1;\n  } else if (clientY >= bottom - des) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * Auto expand all related node when sub node is expanded\n * @param keyList\n * @param props\n * @returns [string]\n */\n\nexport function calcExpandedKeys(keyList, props) {\n  if (!keyList) {\n    return [];\n  }\n\n  var children = props.children; // Fill parent expanded keys\n\n  var _getNodesStatistic = getNodesStatistic(children),\n      keyNodes = _getNodesStatistic.keyNodes,\n      nodeList = _getNodesStatistic.nodeList;\n\n  var needExpandKeys = {};\n  var needExpandPathList = []; // Fill expanded nodes\n\n  keyList.forEach(function (key) {\n    var node = keyNodes[key];\n\n    if (node) {\n      needExpandKeys[key] = true;\n      needExpandPathList.push(node.pos);\n    }\n  }); // Match parent by path\n\n  nodeList.forEach(function (_ref5) {\n    var pos = _ref5.pos,\n        key = _ref5.key;\n\n    if (needExpandPathList.some(function (childPos) {\n      return isParent(pos, childPos);\n    })) {\n      needExpandKeys[key] = true;\n    }\n  });\n  var calcExpandedKeyList = Object.keys(needExpandKeys); // [Legacy] Return origin keyList if calc list is empty\n\n  return calcExpandedKeyList.length ? calcExpandedKeyList : keyList;\n}\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\n\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) {\n    return undefined;\n  }\n\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n\n  return selectedKeys;\n}\n/**\n * Check conduct is by key level. It pass though up & down.\n * When conduct target node is check means already conducted will be skip.\n * @param treeNodes\n * @param checkedKeys\n * @returns {{checkedKeys: Array, halfCheckedKeys: Array}}\n */\n\nexport function calcCheckStateConduct(treeNodes, checkedKeys) {\n  var _getNodesStatistic2 = getNodesStatistic(treeNodes),\n      keyNodes = _getNodesStatistic2.keyNodes,\n      posNodes = _getNodesStatistic2.posNodes;\n\n  var tgtCheckedKeys = {};\n  var tgtHalfCheckedKeys = {}; // Conduct up\n\n  function conductUp(key, halfChecked) {\n    if (tgtCheckedKeys[key]) return;\n    var _keyNodes$key = keyNodes[key],\n        _keyNodes$key$subNode = _keyNodes$key.subNodes,\n        subNodes = _keyNodes$key$subNode === undefined ? [] : _keyNodes$key$subNode,\n        parentPos = _keyNodes$key.parentPos,\n        node = _keyNodes$key.node;\n    if (isCheckDisabled(node)) return;\n    var allSubChecked = !halfChecked && subNodes.filter(function (sub) {\n      return !isCheckDisabled(sub.node);\n    }).every(function (sub) {\n      return tgtCheckedKeys[sub.key];\n    });\n\n    if (allSubChecked) {\n      tgtCheckedKeys[key] = true;\n    } else {\n      tgtHalfCheckedKeys[key] = true;\n    }\n\n    if (parentPos !== null) {\n      conductUp(posNodes[parentPos].key, !allSubChecked);\n    }\n  } // Conduct down\n\n\n  function conductDown(key) {\n    if (tgtCheckedKeys[key]) return;\n    var _keyNodes$key2 = keyNodes[key],\n        _keyNodes$key2$subNod = _keyNodes$key2.subNodes,\n        subNodes = _keyNodes$key2$subNod === undefined ? [] : _keyNodes$key2$subNod,\n        node = _keyNodes$key2.node;\n    if (isCheckDisabled(node)) return;\n    tgtCheckedKeys[key] = true;\n    subNodes.forEach(function (sub) {\n      conductDown(sub.key);\n    });\n  }\n\n  function conduct(key) {\n    if (!keyNodes[key]) {\n      warning(false, '\\'' + key + '\\' does not exist in the tree.');\n      return;\n    }\n\n    var _keyNodes$key3 = keyNodes[key],\n        _keyNodes$key3$subNod = _keyNodes$key3.subNodes,\n        subNodes = _keyNodes$key3$subNod === undefined ? [] : _keyNodes$key3$subNod,\n        parentPos = _keyNodes$key3.parentPos,\n        node = _keyNodes$key3.node;\n    tgtCheckedKeys[key] = true;\n    if (isCheckDisabled(node)) return; // Conduct down\n\n    subNodes.filter(function (sub) {\n      return !isCheckDisabled(sub.node);\n    }).forEach(function (sub) {\n      conductDown(sub.key);\n    }); // Conduct up\n\n    if (parentPos !== null) {\n      conductUp(posNodes[parentPos].key);\n    }\n  }\n\n  checkedKeys.forEach(function (key) {\n    conduct(key);\n  });\n  return {\n    checkedKeys: Object.keys(tgtCheckedKeys),\n    halfCheckedKeys: Object.keys(tgtHalfCheckedKeys).filter(function (key) {\n      return !tgtCheckedKeys[key];\n    })\n  };\n}\n/**\n * Calculate the value of checked and halfChecked keys.\n * This should be only run in init or props changed.\n */\n\nexport function calcCheckedKeys(keys, props) {\n  var checkable = props.checkable,\n      children = props.children,\n      checkStrictly = props.checkStrictly;\n\n  if (!checkable || !keys) {\n    return null;\n  } // Convert keys to object format\n\n\n  var keyProps = void 0;\n\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (typeof keys === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`CheckedKeys` is not an array or an object');\n    return null;\n  } // Do nothing if is checkStrictly mode\n\n\n  if (checkStrictly) {\n    return keyProps;\n  } // Conduct calculate the check status\n\n\n  var _keyProps = keyProps,\n      _keyProps$checkedKeys = _keyProps.checkedKeys,\n      checkedKeys = _keyProps$checkedKeys === undefined ? [] : _keyProps$checkedKeys;\n  return calcCheckStateConduct(children, checkedKeys);\n}","map":{"version":3,"sources":["/Users/administrator/Desktop/DrChain/drchain_frontend/drchain/node_modules/rc-tree/es/util.js"],"names":["Children","warning","DRAG_SIDE_RANGE","DRAG_MIN_GAP","arrDel","list","value","clone","slice","index","indexOf","splice","arrAdd","push","posToArr","pos","split","getPosition","level","getNodeChildren","children","childList","Array","isArray","filter","child","type","isTreeNode","isCheckDisabled","node","_ref","props","disabled","disableCheckbox","traverseTreeNodes","treeNodes","subTreeData","callback","processNode","parent","data","key","parentPos","subNodes","forEach","subNode","subIndex","subPos","getStrictlyValue","checkedKeys","halfChecked","checked","getFullKeyList","keyList","_ref2","isParent","childPos","directly","arguments","length","undefined","parentPath","childPath","len","i","getNodesStatistic","statistic","keyNodes","posNodes","nodeList","_ref3","getDragNodesKeys","_node$props","eventKey","dragNodesKeys","_ref4","nodePos","calcDropPosition","event","treeNode","clientY","_treeNode$selectHandl","selectHandle","getBoundingClientRect","top","bottom","height","des","Math","max","calcExpandedKeys","_getNodesStatistic","needExpandKeys","needExpandPathList","_ref5","some","calcExpandedKeyList","Object","keys","calcSelectedKeys","selectedKeys","multiple","calcCheckStateConduct","_getNodesStatistic2","tgtCheckedKeys","tgtHalfCheckedKeys","conductUp","_keyNodes$key","_keyNodes$key$subNode","allSubChecked","sub","every","conductDown","_keyNodes$key2","_keyNodes$key2$subNod","conduct","_keyNodes$key3","_keyNodes$key3$subNod","halfCheckedKeys","calcCheckedKeys","checkable","checkStrictly","keyProps","_keyProps","_keyProps$checkedKeys"],"mappings":"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","sourcesContent":["/* eslint no-loop-func: 0*/\nimport { Children } from 'react';\nimport warning from 'warning';\n\nvar DRAG_SIDE_RANGE = 0.25;\nvar DRAG_MIN_GAP = 2;\n\nexport function arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n  return clone;\n}\n\nexport function arrAdd(list, value) {\n  var clone = list.slice();\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n  return clone;\n}\n\nexport function posToArr(pos) {\n  return pos.split('-');\n}\n\nexport function getPosition(level, index) {\n  return level + '-' + index;\n}\n\nexport function getNodeChildren(children) {\n  var childList = Array.isArray(children) ? children : [children];\n  return childList.filter(function (child) {\n    return child && child.type && child.type.isTreeNode;\n  });\n}\n\nexport function isCheckDisabled(node) {\n  var _ref = node.props || {},\n      disabled = _ref.disabled,\n      disableCheckbox = _ref.disableCheckbox;\n\n  return !!(disabled || disableCheckbox);\n}\n\nexport function traverseTreeNodes(treeNodes, subTreeData, callback) {\n  if (typeof subTreeData === 'function') {\n    callback = subTreeData;\n    subTreeData = false;\n  }\n\n  function processNode(node, index, parent) {\n    var children = node ? node.props.children : treeNodes;\n    var pos = node ? getPosition(parent.pos, index) : 0;\n\n    // Filter children\n    var childList = getNodeChildren(children);\n\n    // Process node if is not root\n    if (node) {\n      var data = {\n        node: node,\n        index: index,\n        pos: pos,\n        key: node.key || pos,\n        parentPos: parent.node ? parent.pos : null\n      };\n\n      // Children data is not must have\n      if (subTreeData) {\n        // Statistic children\n        var subNodes = [];\n        Children.forEach(childList, function (subNode, subIndex) {\n          // Provide limit snapshot\n          var subPos = getPosition(pos, index);\n          subNodes.push({\n            node: subNode,\n            key: subNode.key || subPos,\n            pos: subPos,\n            index: subIndex\n          });\n        });\n        data.subNodes = subNodes;\n      }\n\n      // Can break traverse by return false\n      if (callback(data) === false) {\n        return;\n      }\n    }\n\n    // Process children node\n    Children.forEach(childList, function (subNode, subIndex) {\n      processNode(subNode, subIndex, { node: node, pos: pos });\n    });\n  }\n\n  processNode(null);\n}\n\n/**\n * [Legacy] Return halfChecked when it has value.\n * @param checkedKeys\n * @param halfChecked\n * @returns {*}\n */\nexport function getStrictlyValue(checkedKeys, halfChecked) {\n  if (halfChecked) {\n    return { checked: checkedKeys, halfChecked: halfChecked };\n  }\n  return checkedKeys;\n}\n\nexport function getFullKeyList(treeNodes) {\n  var keyList = [];\n  traverseTreeNodes(treeNodes, function (_ref2) {\n    var key = _ref2.key;\n\n    keyList.push(key);\n  });\n  return keyList;\n}\n\n/**\n * Check position relation.\n * @param parentPos\n * @param childPos\n * @param directly only directly parent can be true\n * @returns {boolean}\n */\nexport function isParent(parentPos, childPos) {\n  var directly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!parentPos || !childPos || parentPos.length > childPos.length) return false;\n\n  var parentPath = posToArr(parentPos);\n  var childPath = posToArr(childPos);\n\n  // Directly check\n  if (directly && parentPath.length !== childPath.length - 1) return false;\n\n  var len = parentPath.length;\n  for (var i = 0; i < len; i += 1) {\n    if (parentPath[i] !== childPath[i]) return false;\n  }\n\n  return true;\n}\n\n/**\n * Statistic TreeNodes info\n * @param treeNodes\n * @returns {{}}\n */\nexport function getNodesStatistic(treeNodes) {\n  var statistic = {\n    keyNodes: {},\n    posNodes: {},\n    nodeList: []\n  };\n\n  traverseTreeNodes(treeNodes, true, function (_ref3) {\n    var node = _ref3.node,\n        index = _ref3.index,\n        pos = _ref3.pos,\n        key = _ref3.key,\n        subNodes = _ref3.subNodes,\n        parentPos = _ref3.parentPos;\n\n    var data = { node: node, index: index, pos: pos, key: key, subNodes: subNodes, parentPos: parentPos };\n    statistic.keyNodes[key] = data;\n    statistic.posNodes[pos] = data;\n    statistic.nodeList.push(data);\n  });\n\n  return statistic;\n}\n\nexport function getDragNodesKeys(treeNodes, node) {\n  var _node$props = node.props,\n      eventKey = _node$props.eventKey,\n      pos = _node$props.pos;\n\n  var dragNodesKeys = [];\n\n  traverseTreeNodes(treeNodes, function (_ref4) {\n    var nodePos = _ref4.pos,\n        key = _ref4.key;\n\n    if (isParent(pos, nodePos)) {\n      dragNodesKeys.push(key);\n    }\n  });\n  dragNodesKeys.push(eventKey || pos);\n  return dragNodesKeys;\n}\n\n// Only used when drag, not affect SSR.\nexport function calcDropPosition(event, treeNode) {\n  var clientY = event.clientY;\n\n  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),\n      top = _treeNode$selectHandl.top,\n      bottom = _treeNode$selectHandl.bottom,\n      height = _treeNode$selectHandl.height;\n\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\n\n  if (clientY <= top + des) {\n    return -1;\n  } else if (clientY >= bottom - des) {\n    return 1;\n  }\n\n  return 0;\n}\n\n/**\n * Auto expand all related node when sub node is expanded\n * @param keyList\n * @param props\n * @returns [string]\n */\nexport function calcExpandedKeys(keyList, props) {\n  if (!keyList) {\n    return [];\n  }\n\n  var children = props.children;\n\n  // Fill parent expanded keys\n\n  var _getNodesStatistic = getNodesStatistic(children),\n      keyNodes = _getNodesStatistic.keyNodes,\n      nodeList = _getNodesStatistic.nodeList;\n\n  var needExpandKeys = {};\n  var needExpandPathList = [];\n\n  // Fill expanded nodes\n  keyList.forEach(function (key) {\n    var node = keyNodes[key];\n    if (node) {\n      needExpandKeys[key] = true;\n      needExpandPathList.push(node.pos);\n    }\n  });\n\n  // Match parent by path\n  nodeList.forEach(function (_ref5) {\n    var pos = _ref5.pos,\n        key = _ref5.key;\n\n    if (needExpandPathList.some(function (childPos) {\n      return isParent(pos, childPos);\n    })) {\n      needExpandKeys[key] = true;\n    }\n  });\n\n  var calcExpandedKeyList = Object.keys(needExpandKeys);\n\n  // [Legacy] Return origin keyList if calc list is empty\n  return calcExpandedKeyList.length ? calcExpandedKeyList : keyList;\n}\n\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) {\n    return undefined;\n  }\n\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n  return selectedKeys;\n}\n\n/**\n * Check conduct is by key level. It pass though up & down.\n * When conduct target node is check means already conducted will be skip.\n * @param treeNodes\n * @param checkedKeys\n * @returns {{checkedKeys: Array, halfCheckedKeys: Array}}\n */\nexport function calcCheckStateConduct(treeNodes, checkedKeys) {\n  var _getNodesStatistic2 = getNodesStatistic(treeNodes),\n      keyNodes = _getNodesStatistic2.keyNodes,\n      posNodes = _getNodesStatistic2.posNodes;\n\n  var tgtCheckedKeys = {};\n  var tgtHalfCheckedKeys = {};\n\n  // Conduct up\n  function conductUp(key, halfChecked) {\n    if (tgtCheckedKeys[key]) return;\n\n    var _keyNodes$key = keyNodes[key],\n        _keyNodes$key$subNode = _keyNodes$key.subNodes,\n        subNodes = _keyNodes$key$subNode === undefined ? [] : _keyNodes$key$subNode,\n        parentPos = _keyNodes$key.parentPos,\n        node = _keyNodes$key.node;\n\n    if (isCheckDisabled(node)) return;\n\n    var allSubChecked = !halfChecked && subNodes.filter(function (sub) {\n      return !isCheckDisabled(sub.node);\n    }).every(function (sub) {\n      return tgtCheckedKeys[sub.key];\n    });\n\n    if (allSubChecked) {\n      tgtCheckedKeys[key] = true;\n    } else {\n      tgtHalfCheckedKeys[key] = true;\n    }\n\n    if (parentPos !== null) {\n      conductUp(posNodes[parentPos].key, !allSubChecked);\n    }\n  }\n\n  // Conduct down\n  function conductDown(key) {\n    if (tgtCheckedKeys[key]) return;\n    var _keyNodes$key2 = keyNodes[key],\n        _keyNodes$key2$subNod = _keyNodes$key2.subNodes,\n        subNodes = _keyNodes$key2$subNod === undefined ? [] : _keyNodes$key2$subNod,\n        node = _keyNodes$key2.node;\n\n\n    if (isCheckDisabled(node)) return;\n\n    tgtCheckedKeys[key] = true;\n\n    subNodes.forEach(function (sub) {\n      conductDown(sub.key);\n    });\n  }\n\n  function conduct(key) {\n    if (!keyNodes[key]) {\n      warning(false, '\\'' + key + '\\' does not exist in the tree.');\n      return;\n    }\n\n    var _keyNodes$key3 = keyNodes[key],\n        _keyNodes$key3$subNod = _keyNodes$key3.subNodes,\n        subNodes = _keyNodes$key3$subNod === undefined ? [] : _keyNodes$key3$subNod,\n        parentPos = _keyNodes$key3.parentPos,\n        node = _keyNodes$key3.node;\n\n    tgtCheckedKeys[key] = true;\n\n    if (isCheckDisabled(node)) return;\n\n    // Conduct down\n    subNodes.filter(function (sub) {\n      return !isCheckDisabled(sub.node);\n    }).forEach(function (sub) {\n      conductDown(sub.key);\n    });\n\n    // Conduct up\n    if (parentPos !== null) {\n      conductUp(posNodes[parentPos].key);\n    }\n  }\n\n  checkedKeys.forEach(function (key) {\n    conduct(key);\n  });\n\n  return {\n    checkedKeys: Object.keys(tgtCheckedKeys),\n    halfCheckedKeys: Object.keys(tgtHalfCheckedKeys).filter(function (key) {\n      return !tgtCheckedKeys[key];\n    })\n  };\n}\n\n/**\n * Calculate the value of checked and halfChecked keys.\n * This should be only run in init or props changed.\n */\nexport function calcCheckedKeys(keys, props) {\n  var checkable = props.checkable,\n      children = props.children,\n      checkStrictly = props.checkStrictly;\n\n\n  if (!checkable || !keys) {\n    return null;\n  }\n\n  // Convert keys to object format\n  var keyProps = void 0;\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (typeof keys === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`CheckedKeys` is not an array or an object');\n    return null;\n  }\n\n  // Do nothing if is checkStrictly mode\n  if (checkStrictly) {\n    return keyProps;\n  }\n\n  // Conduct calculate the check status\n  var _keyProps = keyProps,\n      _keyProps$checkedKeys = _keyProps.checkedKeys,\n      checkedKeys = _keyProps$checkedKeys === undefined ? [] : _keyProps$checkedKeys;\n\n  return calcCheckStateConduct(children, checkedKeys);\n}"]},"metadata":{},"sourceType":"module"}